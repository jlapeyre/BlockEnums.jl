var documenterSearchIndex = {"docs":
[{"location":"#BlockEnums.jl","page":"BlockEnums.jl","title":"BlockEnums.jl","text":"","category":"section"},{"location":"","page":"BlockEnums.jl","title":"BlockEnums.jl","text":"","category":"page"},{"location":"#BlockEnums","page":"BlockEnums.jl","title":"BlockEnums","text":"","category":"section"},{"location":"","page":"BlockEnums.jl","title":"BlockEnums.jl","text":"BlockEnums\nBlockEnum","category":"page"},{"location":"#BlockEnums","page":"BlockEnums.jl","title":"BlockEnums","text":"module BlockEnums\n\nBlockEnums is a package (and module) providing the type BlockEnum. Concrete subtypes are created with the @blockenum macro, which is similar to Enums.@enum.\n\n\n\n\n\n","category":"module"},{"location":"#BlockEnums.BlockEnum","page":"BlockEnums.jl","title":"BlockEnums.BlockEnum","text":"BlockEnum{T<:Integer}\n\nThe abstract supertype of all enumerated types defined with @blockenum.\n\n\n\n\n\n","category":"type"},{"location":"","page":"BlockEnums.jl","title":"BlockEnums.jl","text":"Create a new BlockEnum with the macro @blockenum.","category":"page"},{"location":"","page":"BlockEnums.jl","title":"BlockEnums.jl","text":"@blockenum","category":"page"},{"location":"#BlockEnums.@blockenum","page":"BlockEnums.jl","title":"BlockEnums.@blockenum","text":"@blockenum EnumName[::BaseType] value1[=x] value2[=y]\n@blockenum (EnumName[::BaseType], [keyword=val,...]) [value1, value2,...]\n\nCreate a BlockEnum{BaseType} subtype with name EnumName and enum member values of value1 and value2 with optional assigned values of x and y, respectively.\n\nKeywords\n\nmod=Modname – EnumName and its instances will be namespaced in a module Modname, which will be created.\nblocklength=n – n is a literal Int. The common length of each \"block\" of enums.\nnumblocks=m – m is a literal Int. The intial number of blocks to create.\ncompactshow – a literal Bool.  If true, then do not print the equivalent BaseType value of instances.\n\nEnumName can be used just like other types and enum member values as regular values, such as\n\nExamples\n\njulia> @blockenum Fruit apple=1 orange=2 kiwi=3\n\njulia> f(x::Fruit) = \"I'm a Fruit with value: $(Int(x))\"\nf (generic function with 1 method)\n\njulia> f(apple)\n\"I'm a Fruit with value: 1\"\n\njulia> Fruit(1)\napple::Fruit = 1\n\nAdd more instances like this\n\njulia> @add Fruit banana lemon\n\nValues can also be specified inside a begin block, e.g.\n\n@blockenum EnumName begin\n    value1\n    value2\nend\n\nBaseType, which defaults to Int32, must be a primitive subtype of Integer. Member values can be converted between the enum type and BaseType. read and write perform these conversions automatically. In case the enum is created with a non-default BaseType, Integer(value1) will return the integer value1 with the type BaseType.\n\nTo list all the instances of an enum use instances, e.g.\n\njulia> instances(Fruit)\n(apple, orange, kiwi, banana, lemon)\n\nIt is possible to construct a symbol from an enum instance:\n\njulia> Symbol(apple)\n:apple\n\nExamples of adding instances to blocks.\n\njulia> using BlockEnums\n\njulia> @blockenum (Myenum, mod=MyenumMod, blocklength=100, numblocks=10, compactshow=false)\n\njulia> @addinblock Myenum 1 a b c\nc::Myenum = 3\n\njulia> @addinblock Myenum 3 x y z\nz::Myenum = 203\n\njulia> BlockEnums.blockindex(MyenumMod.y)\n3\n\nSee @add, @addinblock\n\n\n\n\n\n","category":"macro"},{"location":"","page":"BlockEnums.jl","title":"BlockEnums.jl","text":"These functions retrieve information on BlockEnums.","category":"page"},{"location":"","page":"BlockEnums.jl","title":"BlockEnums.jl","text":"namemap\nbasetype\nBlockEnums.val\ngetmodule\nBlockEnums.compact_show\ninstances(::Type{<:BlockEnum})\nlength(::Type{<:BlockEnum})","category":"page"},{"location":"#BlockEnums.namemap","page":"BlockEnums.jl","title":"BlockEnums.namemap","text":"namemap(::Type{<:BlockEnum})\n\nReturn the Dict mapping all values to name symbols.\n\nThis is not a method of of the function of the same name with methods defined on Base.Enum. Rather it is a function in the BlockEnums module. Perhaps this should not be advertized or exposed.\n\n\n\n\n\n","category":"function"},{"location":"#BlockEnums.basetype","page":"BlockEnums.jl","title":"BlockEnums.basetype","text":"basetype(V::Type{<:BlockEnum{T}})\n\nReturn T, which is the bitstype whose values are bitcast to the type V. This is the type of the value returned by Integer(x::V). The type is in a sense the underlying type of V.\n\n\n\n\n\n","category":"function"},{"location":"#BlockEnums.val","page":"BlockEnums.jl","title":"BlockEnums.val","text":"val(x::BlockEnum{T})\n\nReturn x bitcast to type T.\n\n\n\n\n\n","category":"function"},{"location":"#BlockEnums.getmodule","page":"BlockEnums.jl","title":"BlockEnums.getmodule","text":"getmodule(t::Type{<:BlockEnum})\n\nGet the module in which t is defined.\n\n\n\n\n\n","category":"function"},{"location":"#BlockEnums.compact_show","page":"BlockEnums.jl","title":"BlockEnums.compact_show","text":"compact_show(t::Type{<:BlockEnum})\n\nReturn true if compact show was set when t was defined. This omits printing the corresponding integer when printing. To enable compact show, include the key/val pair compactshow=true when defining t.\n\n\n\n\n\n","category":"function"},{"location":"#Base.instances-Tuple{Type{<:BlockEnum}}","page":"BlockEnums.jl","title":"Base.instances","text":"instances(t::Type{<:BlockEnum})\n\nReturn a Tuple of all of the named values of t.\n\n\n\n\n\n","category":"method"},{"location":"#Base.length-Tuple{Type{<:BlockEnum}}","page":"BlockEnums.jl","title":"Base.length","text":"length(T::Type{<:BlockEnum})\n\nReturn the number of instances of type T.\n\n\n\n\n\n","category":"method"},{"location":"","page":"BlockEnums.jl","title":"BlockEnums.jl","text":"A few functions and macros pertain to the blocks feature.","category":"page"},{"location":"","page":"BlockEnums.jl","title":"BlockEnums.jl","text":"addblocks!\nmaxvalind\nnumblocks\nblocklength\nblockindex\nblockrange\nadd!\n@add\nadd_in_block!\n@addinblock\ninblock\ngtblock\nltblock","category":"page"},{"location":"#BlockEnums.addblocks!","page":"BlockEnums.jl","title":"BlockEnums.addblocks!","text":"addblocks!(t::Type{<:BlockEnum}), nblocks::Integer)\n\nAdd and initialize nblocks blocks to the bookkeeping for t. The number of active blocks for the type is returned.\n\n\n\n\n\n","category":"function"},{"location":"#BlockEnums.maxvalind","page":"BlockEnums.jl","title":"BlockEnums.maxvalind","text":"maxvalind(t::Type{<:BlockEnum}, block_num::Integer)\n\nReturn the largest index for which a name has been assigned in the block_numth block t. This number is constrained to be within the values in the block.\n\n\n\n\n\n","category":"function"},{"location":"#BlockEnums.numblocks","page":"BlockEnums.jl","title":"BlockEnums.numblocks","text":"numblocks(t::Type{<:BlockEnum{T}}) where T <: Integer\n\nReturn the number of blocks for which bookkeeping has been set up. The set of values of t is the nonzero values of T, which is typically very large. Bookkeeping of blocks requires storage. So you can only set up some of the blocks for use.\n\n\n\n\n\n","category":"function"},{"location":"#BlockEnums.blocklength","page":"BlockEnums.jl","title":"BlockEnums.blocklength","text":"blocklength(t::Type{<:BlockEnum})\n\nGet the length of blocks that the range of values of t is partitioned into.\n\n\n\n\n\n","category":"function"},{"location":"#BlockEnums.blockindex","page":"BlockEnums.jl","title":"BlockEnums.blockindex","text":"blockindex(v::BlockEnum)\n\nGet the index of the block of values v belongs to.\n\n\n\n\n\n","category":"function"},{"location":"#BlockEnums.blockrange","page":"BlockEnums.jl","title":"BlockEnums.blockrange","text":"blockrange(t::Type{<:BlockEnum}, blockind)\n\nReturn the range of values of t in block number blockind.\n\n\n\n\n\n","category":"function"},{"location":"#BlockEnums.add!","page":"BlockEnums.jl","title":"BlockEnums.add!","text":"add!(enumname, syms...)\n\nAdd symbols syms to BlockEnum enumname. This function is called by the macro @add.\n\n\n\n\n\n","category":"function"},{"location":"#BlockEnums.@add","page":"BlockEnums.jl","title":"BlockEnums.@add","text":"@add enunmame syms...\n\nAdd symbols syms to BlockEnum named enumname.\n\nExamples\n\n@blockenum MyEnum\n@add MyEnum a b\n\njulia> a\na::MyEnum = 0\n\njulia> b\nb::MyEnum = 1\n\n\n\n\n\n","category":"macro"},{"location":"#BlockEnums.add_in_block!","page":"BlockEnums.jl","title":"BlockEnums.add_in_block!","text":"add_in_block!(a, _block::Union{Integer, BlockEnum}, syms...)\n\nThis is the function called by @addinblock.\n\n\n\n\n\n","category":"function"},{"location":"#BlockEnums.@addinblock","page":"BlockEnums.jl","title":"BlockEnums.@addinblock","text":"@addinblock EnumName blocknum sym1 [sym2,..]\n\nAdd symbols sym1, sym2, etc. to block number blocknum of BlockEnum named EnunName.\n\n\n\n\n\n","category":"macro"},{"location":"#BlockEnums.inblock","page":"BlockEnums.jl","title":"BlockEnums.inblock","text":"inblock(benum::BlockEnum, blockind)\n\nReturn true if benum is in block number blockind of the type of benum.\n\n\n\n\n\n","category":"function"},{"location":"#BlockEnums.gtblock","page":"BlockEnums.jl","title":"BlockEnums.gtblock","text":"gtblock(benum::BlockEnum, blockind)\n\nReturn true if benum is in a block number of the type of benum larger than blockind.\n\n\n\n\n\n","category":"function"},{"location":"#BlockEnums.ltblock","page":"BlockEnums.jl","title":"BlockEnums.ltblock","text":"ltblock(benum::BlockEnum, blockind)\n\nReturn true if benum is in a block number of the type of benum smaller than blockind.\n\n\n\n\n\n","category":"function"},{"location":"#Index","page":"BlockEnums.jl","title":"Index","text":"","category":"section"},{"location":"","page":"BlockEnums.jl","title":"BlockEnums.jl","text":"","category":"page"}]
}
